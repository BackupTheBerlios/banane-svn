%+
% NAME:
%  SyntheticDataHand()
%
% VERSION:
%  $Id: SyntheticDataHand.m 2008-03-12 12:54 furche $
%
% AUTHOR:
%  J. Furche 
%
% DATE CREATED:
%  2008-03-12
%
% AIM:
%  Generates synthetic spike data by overwriting an existing NEV-file
%
% DESCRIPTION:
% syntheticDataHand.m uses mainly the functions synthwaveformsgleicheanzahl.m
% and interspikefktplx2.m to generate a complete spike data file by
% overwriting the spike data from an existing NEV-file. The template units
% are obtained from 5 different experiments that have been sorted manually.
% (the experiments have to be in the same 
% folder as the routines.)
%
% CATEGORY:
%  Statistics
%
% SYNTAX:
%* SyntheticDataHand
%
% INPUTS:
% --
%
% OPTIONAL INPUTS:
%  --
%
% OUTPUTS:
% Since SyntheticDataHand is computed as a script instead of a function,
% each variable is saved in the workspace. Important are:
% speicher: Cell array that contains for each channel necessary information
% about the origins of the units. Column 1 represents the noise; Columns 
% 2,3,4 correspond to the spike units 1,2,3 and the columns 5,6,7 to the 
% undershoots respectively .
% B: Matrix that contains the whole information restored in the NEV-file.
% The rows are sorted in timestamps, which corresponds to column 63. Column
% 1:60 present the waveform, 61 declares the channel, 62 the unit.
%
%
% PROCEDURE:
% syntheticDataHand.m uses mainly the functions synthwaveformsgleicheanzahl.m
% and interspikefktplx2.m to generate a complete spike data file by
% overwriting the spike data from an existing NEV-file. The template units
% are obtained from 5 different experiments that have been sorted 
% manually). For each of the 100
% channels a dice is thrown if 0,1,2 or 3 spike units, 0,1,2 or 3 
% undershoots and noise are computed. Template units are chosen randomly
% out of the preselected ones in channelauswahlHand.m. After this waveforms and
% timestamps are generated by synthwaveformsgleicheanzahl.m
% and interspikefktplx2.m (for more information see the help files of these
% routines). All information about the spikes are stored in the huge matrix
% B, which can be loaded for further analysis, and finally overwritten in
% the existing NEVfile using writeNEV.m.
%
%RESTRICTIONS: 
% Errors may occur by executing the script. Possible reasons are missing
% documents in the current directory (the 5 plx-files have to be there, the
% NEV-file, further the routines channelauswahlHand.m,
% synthewaveformsgleicheanzahl.m, interspikefktplx2.m, plx_waves_v.m and
% the document mexPlex.dll. Besides it is possible that some of the
% specified units don´t have a positive definite covariancematrix (due to
% too less waveforms) - if this error occurs remove this unit from
% channelauswahlHand.m.
%
% EXAMPLE:
% Generate a spike data set by using
%* SyntheticDataHand
%
% SEE ALSO:
%  interspikefktplx2.m,synthewaveformsgleicheanzahl.m
%
%-


%1 INITIALISING
Neu = openNEV('SyntheticDataFile.nev');
    getNEVSpikes(Neu);
    getNEVStimulus(Neu);
    packetindex=Neu.SpikeData.index;
    index=0;
    Riesenmatrix=101*ones(length(packetindex),63,'int32'); 
    streckfaktorvektor=[];
    
for i=1:100; %each electrode
    %initialising
    riesenmatrix1=[]; 
    %noise probability 90%
    rauschen=rand<0.9;
    %Probability for 1,2 or 3 Spikeunits: 47%
    %for 1 Spike, 13% for 2 Spikes, 2% for 3 Spikes. anzahlspikes=4 
    %corresponds to 0 spikes
    [mini,anzahlspikes]=min(rand>[0.47 0.6 0.62 1]); 
    speichermatrix=zeros(5,7);
    speichermatrix(1,:)=[0 1 2 3 1 2 3];
   
    %2 SPIKEFORMS
   if anzahlspikes<4;
       for j=1:anzahlspikes %for each spikeunit:
        [plxnummer,plxdatei,channel,unita]=channelauswahlHand(1); %randomly choosing a channel out of the preselection
        [mu,Waveforms,kurven]=synthwaveformsgleicheanzahl(plxdatei,channel,unita); %generating almost the same number of spikes
        [number,bla]=size(kurven{1}); 
        speichermatrix([2,3,4,5],j+1)=[plxnummer; channel; unita; number] %stores the origin informations of the spikes in columns 2-4
        [abstaende,timestamps,streckfaktor]=interspikefktplx2(plxdatei,channel,unita,number); %timestamps
        streckfaktorvektor=[streckfaktorvektor streckfaktor]; %(just for control)
        units=repmat(j,number,1); 
            %Undershoot:
            if rand<0.15 %15% probability for undershoot. Following operations are analogeous to the spike generation
                [plxnummer,plxdatei,channel,unita]=channelauswahlHand(3);
                [mu,Waveforms,kurven2]=synthwaveformsgleicheanzahl(plxdatei,channel,unita); 
                [number2,bla2]=size(kurven2{1});
                speichermatrix([2,3,4,5],j+4)=[plxnummer; channel; unita; number2] %storing in columns 4-6
                [abstaende,timestamps2,streckfaktor]=interspikefktplx2(plxdatei,channel,unita,number2);
                streckfaktorvektor=[streckfaktorvektor streckfaktor]; 
                number=number+number2; %combining of the waveforms, timestamps and units:
                timestamps=[timestamps timestamps2];
                kurven{1}=[kurven{1};kurven2{1}];
                units=[units; repmat(j+3,number2,1)];
            end
         riesenmatrix1=[riesenmatrix1; kurven{1} repmat(i,number,1) units timestamps']; %riesenmatrix1 contains all information of the waveforms for each channel
       end
   end
   
   %3 Noise
   %Generating of noise analogeous:
   if rauschen==1;
      [plxnummer,plxdatei,channel,unita]=channelauswahlHand(2); 
      [mu,Waveforms,kurven]=synthwaveformsgleicheanzahl(plxdatei,channel,unita); 
      [number,bla]=size(kurven{1});
      speichermatrix([2,3,4,5],1)=[plxnummer; channel; unita; number] 
      [abstaende,timestamps,streckfaktor]=interspikefktplx2(plxdatei,channel,unita,number); 
      streckfaktorvektor=[streckfaktorvektor streckfaktor]; 
      riesenmatrix1=[riesenmatrix1; kurven{1} repmat(i,number,1) repmat(0,number,1) timestamps']; %noise is stored as unit 0.
   end
   
   %4 ADJUSTING THE TIMESTAMPS
   %In order to respect the recording time in real experiments the
   %timestamps of each pair of waveform must differ in at least 60 sample
   %points:
   if size(riesenmatrix1)>0; %Active channel
      riesenmatrix1=sortrows(riesenmatrix1,63);
      riesentimestamps=riesenmatrix1(:,63);
      minimum=min(diff(riesentimestamps));
      if minimum<61 %timestamp differences smaller than 61
        indizes=find(diff(riesentimestamps)<61);
        if indizes(end)<length(riesentimestamps)-1 
        moeglich=riesentimestamps(indizes)+121<riesentimestamps(indizes+2); %moegich contains 1 if it is possible to shift the second timestamp
        else 
            moeglich=riesentimestamps(indizes(1:end-1))+121<riesentimestamps(indizes(1:end-1)+2); 
            moeglich=logical([moeglich; 1]);
        end
            indizesmoeglich=indizes(moeglich); %indizes of timestamps which can be shifted
        riesenmatrix1(indizesmoeglich+1,63)=riesentimestamps(indizesmoeglich)+61; %shifting the timestamps
        %Waveforms which timestamps can´t be shifted are deleted:
        nichtmoeglich=indizes(~moeglich); 
        if length(nichtmoeglich)>0
           herausgenommeneUnits=riesenmatrix1(nichtmoeglich+1,62);
           for k=0:6
                anzahl=sum(herausgenommeneUnits==k) %if waveforms are deleted this has to be recorded in speicher
                speichermatrix(5,k+1)=speichermatrix(5,k+1)-anzahl;
           end
           riesenmatrix1(nichtmoeglich+1,:)=[];   %deleting of the waveforms that can´t be shifted
        end 
      end
      
      
      %5 STORING AND OVERWRITING
      [m1,n1]=size(riesenmatrix1);
      [m,n]=size(Riesenmatrix);
      %Storing riesenmatrix1 into Riesenmatrix which contains all waveforms                           
      if index+m1<length(packetindex)
         Riesenmatrix(index+1:index+m1,:)=riesenmatrix1;
         index=index+m1;
      else %if more waveforms are generated than fit into the original NEV.file (about 910000) only as much as possible are stored and an error occurs containing the information, which channel is the last one containing waveforms. If the file shall be written even though, the operation under (1) has to be performed manually.
         text=num2str(sprintf('Too many waveforms. Channel %g is the last one containing spikes.',i));
         uebrig=length(packetindex)-index; 
         A=kurven{1} ;
         Riesenmatrix(index+1:end,:)=riesenmatrix1(1:uebrig,:);
         error(text)
      end
   end
    speicher{i}=speichermatrix; %Cell array containing the origin information
end


%Sorting of Riesenmatrix.
B=sortrows(Riesenmatrix,63);

%6 SCHREIBEN DES NEV-FILES
clear Riesenmatrix;
%Writing
%(1) If too many waveforms are generated, perform the following steps manually if you are
%interested in writing the file even though:
putPackets(Neu, packetindex, 'waveform', B(:,1:60));
putPackets(Neu, packetindex, 'timeStamp', B(:,63)');
putPackets(Neu, packetindex, 'electrode', B(:,61)');
putPackets(Neu, packetindex, 'unit', B(:,62)');
